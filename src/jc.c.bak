#include "common.c"
#include "obj.c"
#include "vm.c"
#include "lex.c"

int *idmain,
    ty,       // current expression type (目前的運算式型態)
    loc;      // local variable offset (區域變數的位移)

// types (支援型態，只有 int, char, pointer)
enum { CHAR, INT, PTR };

int compile(int fd) {
  int i, *t;
  // 編譯器
  p = "char else enum if int return sizeof while ";
  i = Char; while (i <= While) { next(); id[Tk] = i++; } // add keywords to symbol table
  p = "open read write close printf malloc free memset memcmp exit void main";
  i = OPEN; while (i <= EXIT) { next(); id[Class] = Sys; id[Type] = INT; id[Val] = i++; } // add library to symbol table
  next(); id[Tk] = Char; // handle void type
  next(); idmain = id; // keep track of main

  if (!(source = lp = p = malloc(poolsz))) { printf("could not malloc(%d) source area\n", poolsz); return -1; }
  if ((i = read(fd, source, poolsz-1)) <= 0) { printf("read() returned %d\n", i); return -1; }
  p[i] = 0; // 設定程式 p 字串結束符號 \0

  return lex();
  // return prog();
}

int main(int argc, char **argv) {
  arg_handle(argc, argv);
  obj_init();
  le = e = code; datap = data;
  if (o_dump) { // -u: 印出目的檔
    obj_load(fd);
    obj_dump(entry, code, codeLen, data, dataLen);
    return 0;
  }
  if (o_run) { // -r: 執行目的檔
    obj_load(fd);
    vm(argc, argv);
    return 0;
  }
  if (compile(fd)==-1) return -1; // 編譯
  if (!(entry = (int *)idmain[Val])) { printf("main() not defined\n"); return -1; }
  if (src) return 0; // 編譯並列印，不執行
  if (o_save) { // -o 輸出目的檔，但不執行
    obj_save(oFile, entry, code, e-code+1, data, datap-data);
    printf("Compile %s success!\nOutput: %s\n", iFile, oFile);
    return 0;
  }
  close(fd);
  vm(argc0, argv0); // 用虛擬機執行編譯出來的碼
}
